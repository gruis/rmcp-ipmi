module IPMI
  class Message
    # Based off of the IPMB v1 specification http://www.intel.com/content/www/us/en/servers/ipmi/ipmp-spec-v1-0.html
    class Header

      class << self
        def cksum(*values)
          (values.inject(0) { |c,val| (c + val) % 256 } - 1) ^ 0xff
        end
      end

      # @return [Fixnum] responder's slave address. 1 byte.
      attr_reader :rs_addr
      # @return [Fixnum] response logical unit number
      attr_reader :rs_lun
      # @return [Fixnum] network function code
      attr_reader :net_fn
      # @return [Fixnum] requester's address. 1 byte.
      attr_reader :rq_addr
      # @return [Fixnum] request logical unit number
      attr_reader :rq_lun
      # @return [Fixnum] sequence number generated by the requester
      attr_reader :rq_seq
      # @return [Fixnum] 2's compliment checksum for first three fields (rsSa, netFn, rsLun)
      attr_reader :cksum
      # @return [Fixnum] 2's compliment checksum for cmd, data, rq_seq, rq_lun and rq_sa
      attr_reader :cksum_b

      attr_reader :cmd
      attr_reader :data

      def decode(packet)
        @rs_addr, rs_lun_net_fn, @cksum, @rq_addr, rq_lun_seq, @cmd = packet.unpack("CCCCCC")
        unless (exp = self.class.cksum(@rs_addr, rs_lun_net_fn)) == @cksum
          raise Error::Checksum.new("Expected rs_addr, rs_lun and net_fn checksum to be #{exp} not #{@cksum}")
        end
        @net_fn  = rs_lun_net_fn >> 2
        @rs_lun  = rs_lun_net_fn & 64
        @rq_seq  = rq_lun_seq >> 2
        @rq_lun  = rq_lun_seq & 64
        @data    = packet[6..-2]
        @cksum_b = packet[-1].unpack("C")[0]
        unless (exp = self.class.cksum(@rq_addr, rq_lun_seq, @cmd, *@data.unpack("C*"))) == @cksum_b
          raise Error::Checksum.new("Expected rq_addr, rq_lun, rq_seq, cmd, and data checksum to be #{exp} not #{@cksum_b}")
        end
        self
      end

    end # class::Header
  end # class::Message
end # module::IPMI
